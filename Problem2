# Did this code successfully run on Leetcode : Yes
# Any problem you faced while coding this : No
# Space Complexity : O(1000+n)

# Your code here along with comments explaining your approach
class MyHashSet(object):
    
    def __init__(self):
        # Initialize a list of empty lists (buckets) with a fixed size of 1000
        self.bucket_size = 1000
        self.buckets = [[] for _ in range(self.bucket_size)]

    def _hash(self, key):
        # Hash function to compute the bucket index
        return key % self.bucket_size

    def add(self, key):
        # Time Complexity : O(n)
        """
        :type key: int
        :rtype: None
        """
        # Get the bucket index using the hash function
        bucket_index = self._hash(key)
        bucket = self.buckets[bucket_index]
        # If the key is not already in the bucket, add it
        if key not in bucket:
            bucket.append(key)
        

    def remove(self, key):
        # Time Complexity : O(n)
        """
        :type key: int
        :rtype: None
        """
        # Get the bucket index using the hash function
        bucket_index = self._hash(key)
        bucket = self.buckets[bucket_index]
        # If the key is in the bucket, remove it
        if key in bucket:
            bucket.remove(key)

    def contains(self, key):
        # Time Complexity : O(n)
        """
        :type key: int
        :rtype: bool
        """
        # Get the bucket index using the hash function
        bucket_index = self._hash(key)
        bucket = self.buckets[bucket_index]
        # Check if the key is in the bucket
        return key in bucket
        

# Your MyHashSet object will be instantiated and called as such:
# obj = MyHashSet()
# obj.add(key)
# obj.remove(key)
# param_3 = obj.contains(key)
